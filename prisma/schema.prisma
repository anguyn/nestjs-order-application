generator client {
  provider     = "prisma-client"
  output       = "../src/generated/prisma"
  moduleFormat = "commonjs"
  engineType   = "client"
}

datasource db {
  provider = "postgresql"
}

enum Language {
  EN
  VI
}

model User {
  id                  String    @id @default(uuid())
  email               String    @unique
  password            String
  firstName           String
  lastName            String
  phone               String?
  role                UserRole  @default(USER)
  permissions         String[]  @default([])
  language            Language  @default(EN)
  isActive            Boolean   @default(true)
  isEmailVerified     Boolean   @default(false)
  emailVerifyToken    String?
  emailVerifyExpiry   DateTime?
  resetPasswordToken  String?
  resetPasswordExpiry DateTime?
  lastLoginAt         DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  products         Product[]
  events           Event[]
  carts            Cart[]
  orders           Order[]
  refreshTokens    RefreshToken[]
  editLocks        EditLock[]
  voucherUsages    VoucherUsage[]
  addresses        Address[]
  voucherInstances VoucherInstance[]

  @@map("users")
}

model RefreshToken {
  id         String   @id @default(uuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  deviceInfo String?
  ipAddress  String?

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

model Address {
  id        String  @id @default(uuid())
  userId    String
  fullName  String
  phone     String
  address   String
  ward      String
  district  String
  city      String
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders Order[]

  @@index([userId])
  @@map("addresses")
}

enum UserRole {
  ADMIN
  MERCHANT
  USER
}

model Product {
  id           String        @id @default(uuid())
  name         String
  slug         String        @unique
  description  String        @db.Text
  price        Decimal       @db.Decimal(10, 2)
  comparePrice Decimal?      @db.Decimal(10, 2)
  stock        Int           @default(0)
  sku          String?       @unique
  images       String[]      @default([])
  status       ProductStatus @default(DRAFT)
  createdBy    String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator    User        @relation(fields: [createdBy], references: [id])
  cartItems  CartItem[]
  orderItems OrderItem[]
  editLocks  EditLock[]

  @@index([slug])
  @@index([status])
  @@index([createdBy])
  @@map("products")
}

enum ProductStatus {
  DRAFT
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

model Event {
  id          String  @id @default(uuid())
  slug        String  @unique
  title       String
  description String?

  startDate DateTime
  endDate   DateTime

  maxVouchers Int
  issuedCount Int @default(0)

  isActive  Boolean  @default(true)
  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator          User              @relation(fields: [createdBy], references: [id])
  voucherTemplates VoucherTemplate[]
  editLock         EditLock?

  @@index([startDate, endDate])
  @@index([createdBy])
  @@map("events")
}

model VoucherTemplate {
  id      String @id @default(uuid())
  eventId String

  name        String
  description String?
  code        String? @unique

  discountType      DiscountType
  discountValue     Decimal      @db.Decimal(10, 2)
  minOrderAmount    Decimal?     @db.Decimal(10, 2)
  maxDiscountAmount Decimal?     @db.Decimal(10, 2)

  type          VoucherType
  maxUsageCount Int?
  maxPerUser    Int?

  maxIssue    Int
  issuedCount Int @default(0)

  targetUserIds String[] @default([])

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event            Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  voucherInstances VoucherInstance[]

  @@index([eventId])
  @@index([code])
  @@index([isActive])
  @@map("voucher_templates")
}

model VoucherInstance {
  id         String @id @default(uuid())
  templateId String
  userId     String

  code String @unique

  status    VoucherStatus @default(ACTIVE)
  usedCount Int           @default(0)

  issuedAt   DateTime  @default(now())
  expiresAt  DateTime
  lastUsedAt DateTime?

  template VoucherTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  usages   VoucherUsage[]

  @@index([templateId])
  @@index([userId])
  @@index([code])
  @@index([status])
  @@index([expiresAt])
  @@map("voucher_instances")
}

enum VoucherStatus {
  ACTIVE
  USED
  EXPIRED
  REVOKED
}

model VoucherUsage {
  id                String  @id @default(uuid())
  voucherInstanceId String
  userId            String
  orderId           String
  orderAmount       Decimal @db.Decimal(10, 2)
  discountApplied   Decimal @db.Decimal(10, 2)

  usedAt DateTime @default(now())

  voucherInstance VoucherInstance @relation(fields: [voucherInstanceId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id])
  order           Order           @relation(fields: [orderId], references: [id])

  @@index([voucherInstanceId])
  @@index([userId])
  @@index([orderId])
  @@index([usedAt])
  @@map("voucher_usages")
}

enum VoucherType {
  SINGLE_USE
  MULTI_USE
  SPECIFIC_USER
}

model Cart {
  id     String @id @default(uuid())
  userId String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items CartItem[]

  @@map("carts")
}

model CartItem {
  id        String @id @default(uuid())
  cartId    String
  productId String
  quantity  Int    @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
  @@map("cart_items")
}

model Order {
  id          String @id @default(uuid())
  orderNumber String @unique
  userId      String

  addressText String?
  addressId   String?

  subtotal         Decimal @db.Decimal(10, 2)
  discountAmount   Decimal @default(0) @db.Decimal(10, 2)
  shippingFee      Decimal @default(30000) @db.Decimal(10, 2)
  shippingDiscount Decimal @default(0) @db.Decimal(10, 2)
  totalAmount      Decimal @db.Decimal(10, 2)

  status        OrderStatus   @default(PENDING)
  paymentMethod PaymentMethod // REQUIRED: VIETQR, BANK_TRANSFER, CASH

  vouchersApplied String[] @default([])

  customerNote String? @db.Text
  adminNote    String? @db.Text

  expiresAt   DateTime?
  paidAt      DateTime?
  confirmedAt DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?
  cancelledAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User             @relation(fields: [userId], references: [id])
  address         Address?         @relation(fields: [addressId], references: [id])
  items           OrderItem[]
  payment         Payment?
  voucherUsages   VoucherUsage[]
  paymentDisputes PaymentDispute[]

  @@index([userId])
  @@index([orderNumber])
  @@index([status])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("orders")
}

enum DiscountType {
  FIXED
  PERCENTAGE
  FREE_SHIPPING
}

model OrderItem {
  id          String  @id @default(uuid())
  orderId     String
  productId   String
  productName String
  price       Decimal @db.Decimal(10, 2)
  quantity    Int
  subtotal    Decimal @db.Decimal(10, 2)

  createdAt DateTime @default(now())

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

model Payment {
  id      String        @id @default(uuid())
  orderId String        @unique
  amount  Decimal       @db.Decimal(10, 2)
  method  PaymentMethod @default(VIETQR)
  status  PaymentStatus @default(PENDING)

  transactionId String? @unique
  providerRef   String?
  metadata      Json?

  qrContent  String? @db.Text
  qrImageUrl String?

  sepayOrderCode  String? @unique
  sepayGatewayUrl String?

  providerResponse Json?

  paidAt     DateTime?
  failedAt   DateTime?
  refundedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([transactionId])
  @@index([sepayOrderCode])
  @@index([status])
  @@map("payments")
}

model PaymentDispute {
  id             String    @id @default(cuid())
  orderId        String
  order          Order     @relation(fields: [orderId], references: [id])
  expectedAmount Decimal   @db.Decimal(10, 2)
  receivedAmount Decimal   @db.Decimal(10, 2)
  transactionId  String?
  content        String
  reason         String // AMOUNT_MISMATCH | INVALID_ORDER | DUPLICATE | WRONG_ACCOUNT
  webhookBody    Json
  status         String    @default("PENDING") // PENDING | RESOLVED | REFUNDED | REJECTED
  resolvedAt     DateTime?
  resolvedBy     String?
  resolutionNote String?   @db.Text
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([orderId])
  @@index([status])
  @@index([createdAt])
}

enum OrderStatus {
  PENDING
  PROCESSING
  PAID
  CONFIRMED
  SHIPPING
  DELIVERED
  CANCELLED
  REFUNDED
  EXPIRED
}

enum PaymentMethod {
  BANK_TRANSFER
  VIETQR
  CASH
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

model EditLock {
  id           String   @id @default(uuid())
  resourceType String
  eventId      String?
  productId    String?
  userId       String
  userEmail    String
  lockedAt     DateTime @default(now())
  expiresAt    DateTime

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event   Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  product Product? @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([eventId], name: "unique_event_lock")
  @@unique([productId], name: "unique_product_lock")
  @@index([eventId])
  @@index([productId])
  @@index([expiresAt])
  @@map("edit_locks")
}
